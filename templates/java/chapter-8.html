<div class="content-wrap">
    <h2 class="content__heading-2 mb-10">Inheritance</h2>
    <p class="content__desc mb-10">
        <b>Inheritance</b> là một khái niệm trong lập trình hướng đối tượng,
        cho phép một lớp (subclass) con thừa hưởng các thuộc tính (fields) và phương thức (methods) 
        từ một lớp cha (parent class | superclass).
    </p>
    <p class="content__desc mb-10">
        Lớp con có thể <b>tái sử dụng</b> các thuộc tính và phương thức từ lớp cha.
    </p>
    <p class="content__desc mb-10">
        Đồng thời có thể <b>mở rộng</b> hoặc <b>ghi đè</b> nếu cần. 
        Điều này giúp <b>giảm</b> sự <b>lặp lại</b> trong mã
        và <b>tăng</b> tính <b>tái sử dụng</b>
    </p>
    <h3 class="content__heading-3 mb-10">Override</h3>
    <p class="content__desc mb-10">
        <b>Override</b> là hiện tượng <b>con</b> có hàm trùng tên với hàm của <b>cha</b>.
    </p>
    <p class="content__desc mb-10">
        Override chỉ xảy ra khi khai 
        <b>cha new con</b>. Tức là gọi hàm cha nhưng <b>con ưu tiên</b>. 
        <span class="color-red">(xem hình 8.1 vùng ram của biến tham chiếu s1)</span>
    </p>
    <p class="content__desc">
        Khai con new con thì không thấy, vì gọi trực tiếp hàm con rồi
    </p>
    <h3 class="content__heading-3 mt-20 mb-10">Kế thừa level 1: Concrete class - lớp cụ thể</h3>
    <p class="content__desc mb-10">
        Vùng nhớ cha mở rộng 1 chút thành vùng nhớ con.
    </p>
    <p class="content__desc mb-10">
        Vùng nhớ con = vùng nhớ cha + extends (mở rộng thêm)
    </p>
    <figure class="content-img mb-10">
        <img src="./assets/img/inheritance.jpg" alt="inheritance" class="content-img__img">
        <figcaption>
            <em>Hình 8.1</em>
        </figcaption>
    </figure>
    <p class="content__desc mb-10">
        data
    </p>
    <pre class="language-javascript"><code class="language-javascript">public class Parent {
    protected String assetOne;
    protected String assetTwo;
    
    public Rectangle(String assetOne, String assetTwo) {
        this.assetOne = assetOne;
        this.assetTwo = assetTwo;
    }

    // getter & setter & toString...

    public void showProfile() {
        System.out.printf("Parent - asset1: " + assetOne + " - asset2: " + assetTwo);
    }
}</code></pre>
    <pre class="language-javascript"><code class="language-javascript">public class Child extends Parent {
    public Square(String assetOne, String assetTwo) {
        super(assetOne, assetTwo);
    }

    @Override
    public void showProfile() {
        System.out.printf("Child - asset1: " + assetOne + " - asset2: " + assetTwo);
    }

    public void sayHello() {
        System.out.print("Hi everyone, I'm a rich kid!!!");
    }
}</code></pre>
    <p class="content__desc mb-10">
        <b>super</b> chính là new Parent
    </p>

    <h4 class="content__heading-4 mb-20">Đặt vấn đề: khi khai cha new con</h4>

    <pre class="language-javascript"><code class="language-javascript">Parent child = new Child("Villa", "1000 BTC");</code></pre>
    <p class="content__desc mt-10 mb-10">
        Biến object chấm <b>không thể sờ</b> vào <b>phương thức sayHi()</b>
    </p>
    <p class="content__desc mb-10">
        Lý do: khai báo kiểu cha, chấm theo cha. Mặc dù trong RAM vẫn có.
    </p>
    <p class="content__desc mb-10">
        <b>Cách 1</b>: 
    </p>
    <p class="content__desc mb-10 ti-30">
        Ta sử dụng kỹ thuật DRIFT. Tổ lái con trỏ xuống đáy vùng new. 
    </p>
    <p class="content__desc mb-10 ti-30">
        Tốn 1 biến con trỏ. Kích thước là 8 byte <=> 10^18.
    </p>
    <p class="content__desc mb-10">
        Tại sao lại là 8 byte???
    </p>
    <p class="content__desc mb-10 ti-30">
        Vì máy mình là window 64 bit. Công nghệ là 64 bit. 64 bit tức là thanh RAM nó đánh địa chỉ.
    </p>
    <p class="content__desc mb-10 ti-30">
        Dùng 64 bit để lưu số địa chỉ trong RAM.
        Lưu địa chỉ, lưu tọa độ, tao cần 8 byte.
    </p>
    <p class="content__desc mb-10 ti-30">
        Nghĩa là số nhà được dùng 64 bit để đánh. Cho nên nó cần được lưu 64 bit. Thì nó mới có khả năng trỏ tới các địa chỉ
    </p>
    <blockquote class="blockquote blockquote--normal mb-10">
        <p class="content__desc mb-10">
            Ngoài lề:
        </p>
        <p class="content__desc">
            Cho nên khứa nào sử dụng window-32 bit mà dùng RAM 8gb là vô nghĩa. Vì tối đa là 4gb.
        </p>
    </blockquote>
    <pre class="language-javascript"><code class="language-javascript">Parent child = new Child("Villa", "1000 BTC");
Child tmp = (Child) child; // mày hãy xuống lấy cho tao tọa độ vùng new Child</code></pre>

    <p class="content__desc mt-10 mb-10">
        <b>Cách 2</b>: Ta sử dụng kỹ thuật DRIFT. Tổ lái con trỏ xuống đáy vùng new. (không tốn 1 con trỏ Child)
    </p>
    <pre class="language-javascript"><code class="language-javascript">(Child)c1. // không có ra sayHello()</code></pre>
    <p class="content__desc mt-10 mb-10 ti-30">
        Dấu chấm cực mạnh về độ ưu tiên.
    </p>
    <p class="content__desc mb-10 ti-30">
        Hàm ý: sử dụng vùng ram của biến con trỏ
    </p>
    <p class="content__desc mb-10 ti-30">
        Gắn với đúng data type của biến con trỏ. c1. là biến của cha nên sẽ chấm vào new Cha, vùng ram của cha
    </p>
    <p class="content__desc mb-10">
        Solution: ép kiểu xong đi đã rồi chấm
    </p>
    <pre class="language-javascript"><code class="language-javascript">Parent c1 = new Child("Villa", "1000 BTC");
((Child)c1).sayHello(); </code></pre>

<blockquote class="blockquote blockquote--normal">
    <p class="content__desc mb-10">
        Chốt hạ:
    </p>
    <p class="content__desc mb-10 ti-30">
        Để thấy được hàm dị biệt của con, phải DRIFT con trỏ, kéo dãn sợi dây thun, ép kiểu
    </p>
    <p class="content__desc ti-30">
        2 cách nhưng bản chất là 1. Kéo xuống đáy vùng new.
    </p>
</blockquote>

    <div class="separate"></div>
    <h3 class="content__heading-3 mt-20 mb-10">Kế thừa level 2: Abstract Class (Cha trừu tượng, con cụ thể)</h3>
    <pre class="language-javascript"><code class="language-javascript">public abstract class Shape {
    protected String owner;
    protected String color;
    protected String borderColor;

    // getter & setter & toString()...

    public abstract double getArea();

    public abstract double getPerimeter();
}</code></pre>

    <p class="content__desc mt-10 mb-10">
        Class là gom object
    </p>
    <p class="content__desc mb-10">
        Thì Abstract là dạng gom class, những class có điểm tương đồng
    </p>
    <p class="content__desc mb-10 color-red">
        CÂU HỎI PHỎNG VẤN
    </p>
    <blockquote class="blockquote blockquote--normal">
        <p class="content__desc mb-10">
            <b>Abstract class (lớp trừu tượng)</b> là một loại lớp trong lập trình hướng đối tượng
            được sử dụng để định nghĩa các hành vi chung cho các lớp con,
            nhưng không thể khởi tạo trực tiếp.
        </p>
        <p class="content__desc mb-10">
            Lớp này có thể chứa:
        </p>
        <p class="content__desc mb-10 ti-30">
            <b>Phương thức trừu tượng</b>: Phương thức không có phần triển khai (<b>chỉ có khai báo</b>), 
            buộc các lớp con phải tự định nghĩa lại.
        </p>
        <p class="content__desc mb-10 ti-30">
            <b>Phương thức thông thường</b>: Phương thức có phần triển khai sẵn, các lớp con có thể 
            sử dụng hoặc ghi đè (override) nếu cần.
        </p>
        <p class="content__desc">
            Mục đích của abstract class là tạo ra một khung sườn cho các lớp con, 
            giúp chúng chia sẻ mã chung và đảm bảo các lớp con triển khai đầy đủ các hành vi cần thiết.
        </p>
    </blockquote>
</div>