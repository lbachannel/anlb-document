<div class="content-wrap">
    <h2 class="content__heading-2 mb-20">Làm việc với mảng cơ bản</h2>
    <h3 class="content__heading-3 mb-10">Phương pháp học mảng hiệu quả</h3>
    <p class="content__desc mb-10">
        1. Phương thức này dùng để làm gì, hữu ích trong tình huống nào
    </p>
    <p class="content__desc mb-10">
        2. Những tham số nào, vai trò của từng tham số
    </p>
    <p class="content__desc">
        3. Hàm return về cái gì 
    </p>

    <h3 class="content__heading-3 mt-20 mb-10">push()</h3>
    <p class="content__desc mb-10">
        push() thêm một hoặc nhiều phần tử vào cuối mảng và trả về độ dài mới của mảng.
    </p>
    <pre class="language-javascript"><code class="language-javascript">let fruits = ["Apple", "Banana"];
let newLength = fruits.push("Cherry");

console.log(fruits); // ["Apple", "Banana", "Cherry"]
console.log(newLength) // 3</code></pre>
    <blockquote class="blockquote blockquote--normal mt-10 mb-10">
        <p class="content__desc mb-10">
            <b>Lưu ý</b>: Mảng sẽ bị thay đổi sau khi gọi method này.
        </p>
        <p class="content__desc mb-10">
            <b>Trường hợp sử dụng</b>: Khi muốn <b>thêm một</b> hoặc <b>nhiều phần tử</b> 
            vào cuối mảng. Đây là <b>cách cơ bản</b> và <b>phổ biến nhất</b> để thêm dữ liệu vào một mảng.
        </p>
        <p class="content__desc">
            Ngoài ra, push() <b>có thể nhận nhiều tham số hơn</b>, tương ứng với số phần tử muốn thêm vào cuối mảng.
        </p>
    </blockquote>

    <pre class="language-javascript"><code class="language-javascript">let fruits = ["Apple", "Banana"];

// Thêm nhiều phần tử vào cuối mảng cùng một lúc
fruits.push("Cherry", "Dragonfruit", "Elderberry");

console.log(fruits); // ["Apple", "Banana", "Cherry", "Dragonfruit", "Elderberry"]</code></pre>

    <h3 class="content__heading-3 mt-20 mb-10">pop()</h3>
    <p class="content__desc mb-10">
        pop() loại bỏ phần tử cuối cùng của mảng và trả về phần tử đó.
    </p>
    <pre class="language-javascript"><code class="language-javascript">let fruits = ["Apple", "Banana", "Cherry"];
let lastFruit = fruits.pop();

console.log(lastFruit); // Cherry
console.log(fruits); // ["Apple", "Banana"]</code></pre>

    <blockquote class="blockquote blockquote--normal mt-10 mb-10">
        <p class="content__desc mb-10">
            <b>Lưu ý</b>: Mảng sẽ bị thay đổi sau khi gọi method này.
        </p>
        <p class="content__desc">
            <b>Trường hợp sử dụng</b>: Khi <b>cần xóa</b> và <b>lấy phần tử cuối</b> cùng của <b>mảng</b>.
        </p>
    </blockquote>

    <h3 class="content__heading-3 mt-20 mb-10">unshift()</h3>
    <p class="content__desc mb-10">
        unshift() thêm một hoặc nhiều phần tử vào đầu mảng và trả về độ dài mới của mảng.
    </p>
    <pre class="language-javascript"><code class="language-javascript">let fruits = ["Banana", "Cherry"];
let newLength = fruits.unshift("Apple");

console.log(fruits); // ["Apple", "Banana", "Cherry"]
console.log(newLength); // 3</code></pre>

    <blockquote class="blockquote blockquote--normal mt-10 mb-10">
        <p class="content__desc mb-10">
            <b>Lưu ý</b>: Mảng sẽ bị thay đổi sau khi gọi method này.
        </p>
        <p class="content__desc mb-10">
            <b>Trường hợp sử dụng</b>: Khi muốn <b>thêm một</b> hoặc <b>nhiều phần tử vào đầu mảng</b>. 
            <b>Đặc biệt hữu ích</b> khi bạn muốn <b>giữ nguyên thứ tự của các phần tử sau khi thêm</b> mới.
        </p>
        <p class="content__desc">
            Ngoài ra, unshift() có thể nhận nhiều tham số hơn, tương ứng với số phần tử muốn thêm vào đầu mảng.
        </p>
    </blockquote>

    <pre class="language-javascript"><code class="language-javascript">let numbers = [3, 4, 5];

// Thêm 1 và 2 vào đầu mảng
numbers.unshift(1, 2);

console.log(numbers); // [1, 2, 3, 4, 5]</code></pre>
    
    <h3 class="content__heading-3 mt-20 mb-10">shift()</h3>
    <p class="content__desc mb-10">
        shift() loại bỏ phần tử đầu tiên của mảng và trả về phần tử đó.
    </p>
    <pre class="language-javascript"><code class="language-javascript">let fruits = ["Apple", "Banana", "Cherry"];
let firstFruit = fruits.shift();

console.log(firstFruit); // Apple
console.log(fruits); // ["Banana", "Cherry"]</code></pre>
    <blockquote class="blockquote blockquote--normal mt-10">
        <p class="content__desc mb-10">
            <b>Lưu ý</b>: Mảng sẽ bị thay đổi sau khi gọi method này.
        </p>    
        <p class="content__desc">
            <b>Trường hợp sử dụng</b>: Khi muốn <b>xóa phần tử đầu tiên</b> của mảng 
            và <b>cần sử dụng giá trị của phần tử</b> đó. Phương thức này thường <b>được dùng</b> trong các <b>tình huống</b> như <b>xử lý hàng đợi</b>.
        </p>
    </blockquote>

    <div class="separate"></div>

    <h2 class="content__heading-2 mb-20">Tìm kiếm và kiểm tra phần tử</h2>
    <h3 class="content__heading-3 mb-10">indexOf()</h3>
    <p class="content__desc mb-10">
        indexOf() tìm chỉ số đầu tiên của một phần tử trong mảng. Nếu không tìm thấy, trả về -1.
    </p>
    <pre class="language-javascript"><code class="language-javascript">let fruits = ["Apple", "Banana", "Cherry"];

console.log(fruits.indexOf("Banana")); // 1
console.log(fruits.indexOf("Mango")); // -1</code></pre>

    <blockquote class="blockquote blockquote--normal mt-10 mb-10">
        <p class="content__desc mb-10">
            <b>Lưu ý</b>: So sánh giữa các phần tử là chính xác (strict equality), tức là cả kiểu dữ liệu và giá trị.
        </p>
        <p class="content__desc mb-10">
            <b>Trường hợp sử dụng</b>: Khi cần xác định vị trí của một phần tử trong mảng. 
            Đặc biệt hữu ích khi kiểm tra xem một giá trị có tồn tại trong mảng hay không và biết được vị trí của nó.
        </p>
        <p class="content__desc">
            Ngoài ra, indexOf() có thể nhận thêm một tham số thứ hai, đó là vị trí bắt đầu tìm kiếm trong mảng.
        </p>
    </blockquote>

    <pre class="language-javascript"><code class="language-javascript">let fruits = ["Apple", "Banana", "Cherry", "Apple"];

// Tìm "Apple" bắt đầu từ vị trí 2
console.log(fruits.indexOf("Apple", 2)); // 3</code></pre>

    <h3 class="content__heading-3 mt-20 mb-10">lastIndexOf()</h3>
    <p>
        lastIndexOf() tìm chỉ số cuối cùng của một phần tử trong mảng. Nếu không tìm thấy, trả về -1.
    </p>
    <pre class="language-javascript"><code class="language-javascript">let numbers = [1, 2, 3, 2, 1];

console.log(numbers.lastIndexOf(2)); // 3</code></pre>
    <blockquote class="blockquote blockquote--normal mt-10 mb-10">
        <p class="content__desc mb-10">
            <b>Lưu ý</b>: Tìm kiếm từ cuối mảng về đầu mảng.
        </p>
        <p class="content__desc mb-10">
            <b>Trường hợp sử dụng</b>: Khi cần tìm vị trí xuất hiện cuối cùng của một phần tử, 
            đặc biệt hữu ích trong các mảng có các phần tử lặp lại và bạn muốn biết vị trí lần xuất hiện cuối cùng của chúng.
        </p>
        <p class="content__desc">
            Ngoài ra, giống như indexOf(), lastIndexOf() 
            cũng có thể nhận một tham số thứ hai là vị trí bắt đầu tìm kiếm, nhưng nó sẽ tìm từ cuối mảng lên.
        </p>
    </blockquote>

    <pre class="language-javascript"><code class="language-javascript">let numbers = [1, 2, 3, 4, 2, 5];

// Tìm "2" bắt đầu từ vị trí 4 về đầu mảng
console.log(numbers.lastIndexOf(2, 3)); // 1</code></pre>
    
    <h3 class="content__heading-3 mt-20 mb-10">includes()</h3>
    <p class="content__desc mb-10">
        includes() kiểm tra xem một mảng có chứa một phần tử nhất định hay không, trả về true hoặc false.
    </p>
    <pre class="language-javascript"><code class="language-javascript">let numbers = [1, 2, 3];

console.log(numbers.includes(2)); // true
console.log(numbers.includes(4)); // false</code></pre>

    <blockquote class="blockquote blockquote--normal mt-10">
        <p class="content__desc mb-10">
            <b>Lưu ý</b>: Phương thức này sử dụng same-value-zero comparison algorithm 
            để xác định xem một mảng có chứa một giá trị nhất định hay không. 
            Điều này khác biệt so với strict equality (===) ở chỗ nó coi NaN là bằng nhau (trong khi NaN === NaN trả về false).
        </p>
        <p class="content__desc">
            <b>Trường hợp sử dụng</b>: Khi cần kiểm tra xem một mảng có chứa một phần tử nhất định hay không, 
            mà không quan tâm đến vị trí của phần tử đó.
        </p>
    </blockquote>
    
    <div class="separate"></div>

    <h2 class="content__heading-2 mb-20">Chuyển đổi và đảo ngược mảng</h2>
    <h3 class="content__heading-3 mb-10">join()</h3>
    <p class="content__desc mb-10">
        join() nối tất cả các phần tử của mảng thành một chuỗi, với một dấu phân cách giữa chúng.
    </p>
    <pre class="language-javascript"><code class="language-javascript">let fruits = ["Apple", "Banana", "Cherry"];

console.log(fruits.join(" / ")); // Apple / Banana / Cherry</code></pre>

    <blockquote class="blockquote blockquote--normal mt-10">
        <p class="content__desc mb-10">
            <b>Lưu ý</b>: Nếu mảng có phần tử undefined hoặc null, chúng sẽ được chuyển thành chuỗi rỗng trong chuỗi kết quả.
        </p>
        <p class="content__desc">
            <b>Trường hợp sử dụng</b>: Khi muốn biến một mảng thành một chuỗi, 
            có thể dùng để tạo ra một chuỗi từ các phần tử của mảng, 
            như tạo ra một danh sách được ngăn cách bằng dấu phẩy, hoặc một đoạn văn.
        </p>
    </blockquote>

    <h3 class="content__heading-3 mt-20 mb-10">reverse()</h3>
    <p class="content__desc mb-10">
        reverse() đảo ngược thứ tự của một mảng và trả về mảng đã được đảo ngược.
    </p>
    <pre class="languge-javascript"><code class="language-javascript">let numbers = [1, 2, 3];

// Đảo ngược thứ tự các phần tử
const reversed = numbers.reverse();

console.log(reversed); // [3, 2, 1]</code></pre>

    <blockquote class="blockquote blockquote--normal mt-10">
        <p class="content__desc mb-10">
            <b>Lưu ý</b>: Mảng sẽ bị thay đổi sau khi gọi method này.
        </p>
        <p class="content__desc">
            <b>Trường hợp sử dụng</b>: Khi muốn đảo ngược thứ tự 
            các phần tử trong mảng, có thể dùng cho việc 
            sắp xếp hoặc đơn giản chỉ là để đảo ngược thứ tự hiển thị.
        </p>
    </blockquote>

    <h3 class="content__heading-3 mt-20 mb-10">toString()</h3>
    <p class="content__desc mb-10">
        toString() chuyển đổi mảng thành một 
        chuỗi các giá trị, cách nhau bằng dấu phẩy.
    </p>
    <pre class="language-javascript"><code class="language-javascript">let fruits = ["Apple", "Banana", "Cherry"];

console.log(fruits.toString()); // Apple,Banana,Cherry</code></pre>
<blockquote class="blockquote blockquote--normal mt-10">
    <p class="content__desc mb-10">
        <b>Lưu ý</b>: Tương tự như join() nhưng không thể chỉ định dấu phân cách.
    </p>
    <p class="content__desc">
        <b>Trường hợp sử dụng</b>: Khi cần chuyển một mảng thành một chuỗi 
        để hiển thị hoặc lưu trữ. Phương thức này tự động được gọi khi 
        một mảng cần được chuyển đổi thành chuỗi, như trong việc nối chuỗi (ép kiểu).
    </p>
</blockquote>   

    <h3 class="content__heading-3 mt-20 mb-10">Các sai lầm thường gặp</h3>
    <h4 class="content__heading-4 mb-10">Quên rằng push(), pop(), unshift(), shift() và reverse() thay đổi mảng ban đầu</h4>
    <p class="content__desc mb-10">
        Sai lầm: Sử dụng các phương thức này với suy nghĩ mảng ban đầu 
        không thay đổi, dẫn đến việc mất mát dữ liệu không mong muốn.
    </p>
    <p class="content__desc mb-10">
        Khắc phục: Luôn nhớ rằng những phương thức này sẽ thay đổi mảng gốc.
    </p>
    <p class="content__desc">
        Nếu muốn giữ nguyên mảng ban đầu, cân nhắc sử dụng các phương thức 
        khác hoặc sao chép mảng trước khi thực hiện thay đổi.
    </p>

    <h4 class="content__heading-4 mt-10 mb-10">Sử dụng indexOf() trên mảng có chứa NaN</h4>
    <p class="content__desc mb-10">
        Sai lầm: indexOf() không thể tìm thấy NaN trong mảng 
        vì NaN không bằng chính nó (NaN === NaN là false).
    </p>
    <p class="content__desc">
        Khắc phục: Sử dụng includes() để xử lý trường hợp có NaN.
    </p>

    <div class="separate"></div>

    <h2 class="content__heading-2 mb-20">Phương thức slice() và splice()</h2>
    <h3 class="content__heading-3 mb-10">Tìm hiểu phương thức slice()</h3>
    <p class="content__desc mb-10">
        Phương thức slice() tạo một bản sao hoặc trích xuất một phần 
        của mảng ban đầu mà không làm thay đổi mảng ban đầu.
    </p>
    <p class="content__desc mb-10">
        Nó trả về một mảng mới chứa các phần tử được trích xuất từ mảng gốc.
    </p>
    <pre class="language-javascript"><code class="language-javascript">array.slice(start, end);</code></pre>
    <p class="content__desc mt-10 mb-10">
        Cách sử dụng:
    </p>
    <p class="content__desc mb-10 ti-30">
        slice(): Trích xuất toàn bộ mảng.
    </p>
    <p class="content__desc mb-10 ti-30">
        slice(start): Trích xuất mảng bắt đầu từ chỉ số start đến cuối mảng.
    </p>
    <p class="content__desc mb-10 ti-30">
        slice(start, end): Trích xuất một phần của mảng từ chỉ số start đến trước chỉ số end.
    </p>

    <pre class="language-javascript"><code class="language-javascript">let fruits = [
    "Apple",
    "Banana",
    "Mango",
    "Orange",
    "Papaya"
];
let result = fruits.slice(2, 4);

console.log(result); // ["Mango", "Orange"]</code></pre>
    
    <p class="content__desc mt-10 mb-10">
        slice() rất hữu ích khi bạn cần tạo một bản sao nhanh chóng của một 
        phần mảng mà không muốn thay đổi mảng gốc. Nó cho phép bạn:
    </p>
    <p class="content__desc mb-10">
        Trích xuất một phần của mảng mà không gây ảnh hưởng đến mảng ban đầu.
    </p>
    <p class="content__desc">
        Tạo bản sao của mảng để thực hiện thao tác trên 
        đó mà không làm ảnh hưởng dữ liệu mảng ban đầu.
    </p>

    <h3 class="content__heading-3 mt-20 mb-10">Các cách làm việc với slice()</h3>
    <h4 class="content__heading-4 mb-10">1. Tạo bản sao của toàn bộ mảng</h4>
    <p class="content__desc mb-10">
        Để tạo một bản sao của toàn bộ mảng, 
        bạn có thể gọi slice() mà không cần truyền tham số (hoặc truyền số 0).
    </p>
    <pre class="language-javascript"><code class="language-javascript">let numbers = [1, 2, 3, 4, 5];
let copyOfNumbers = numbers.slice();
// hoặc: let copyOfNumbers = numbers.slice(0);

console.log(copyOfNumbers); // [1, 2, 3, 4, 5]</code></pre>

    <blockquote class="blockquote blockquote--normal mt-10">
        <p class="content__desc">
            Lúc này, việc chỉnh sửa vào mảng copyOfNumbers 
            sẽ không ảnh hưởng tới mảng ban đầu (numbers).
        </p>
    </blockquote>

    <h4 class="content__heading-4 mt-10 mb-10">2. Trích xuất một phần của mảng</h4>
    <p class="content__desc mb-10">
        Bạn có thể trích xuất một phần của mảng bằng cách chỉ định chỉ số bắt đầu và kết thúc.
    </p>
    <pre class="language-javascript"><code class="language-javascript">let numbers = [1, 2, 3, 4, 5];
let result = numbers.slice(1, 4);

console.log(result); // [2, 3, 4]</code></pre>
        
    <blockquote class="blockquote blockquote--normal mt-10">
        <p class="content__desc">
            Ví dụ, bạn có một danh sách sản phẩm và trên trang chủ của 
            bạn chỉ muốn hiển thị 3 sản phẩm đầu tiên, 
            bạn có thể sử dụng array.slice(0, 3) để lấy ra mảng mới gồm 3 phần tử đầu tiên của mảng.
        </p>
    </blockquote>
    <h4 class="content__heading-4 mt-10 mb-10">3. Sử dụng chỉ số âm</h4>
    <p class="content__desc mb-10">
        slice() cũng hỗ trợ chỉ số âm, nơi -1 đại diện cho phần tử cuối cùng của mảng.
    </p>
    <pre class="language-javascript"><code class="language-javascript">let numbers = [1, 2, 3, 4, 5];
let result = numbers.slice(-3);

console.log(result); // [3, 4, 5]</code></pre>
    <blockquote class="blockquote blockquote--normal mt-10">
        <p class="content__desc">
            Ví dụ, bạn có một danh sách các thông báo và chỉ muốn 
            hiển thị 5 thông báo mới nhất trên giao diện, 
            bạn có thể sử dụng array.slice(-5) để lấy ra 
            mảng mới gồm 5 phần tử cuối cùng của mảng.
        </p>
    </blockquote>

    <div class="separate"></div>
    <h2 class="content__heading-2 mb-20">Tìm hiểu phương thức splice()</h2>
    <h3 class="content__heading-3 mb-10">Phương thức splice() là gì?</h3>
    <p class="content__desc mb-10">
        Phương thức splice() được sử dụng để thêm hoặc loại bỏ các phần tử trong một mảng
    </p>
    <p class="content__desc mb-10">
        Nó hữu ích khi muốn thêm và loại bỏ phần tử tại bất kỳ vị trí nào trong mảng.
    </p>
    <p class="content__desc mb-10">
        Phương thức này sẽ sửa đổi vào mảng ban đầu.
    </p>
    <pre class="language-javascript"><code class="language-javascript">array.splice(start, deleteCount, item1, item2, ...);</code></pre>
    <p class="content__desc mb-10">
        Ý nghĩa các tham số:
    </p>
    <p class="content__desc mb-10 ti-30">
        start: chỉ định vị trí bắt đầu thêm hoặc loại bỏ phần tử trong mảng.
    </p>
    <p class="content__desc mb-10 ti-30">
        Nếu giá trị này là âm, start sẽ được tính từ cuối mảng, 
        với -1 là phần tử cuối cùng của mảng.
    </p>
    <p class="content__desc mb-10 ti-30">
        deleteCount (tùy chọn): số lượng phần tử cần loại bỏ, bắt đầu từ vị trí start.
    </p>
    <p class="content__desc mb-10 ti-30">
        Nếu deleteCount bị bỏ qua hoặc lớn hơn số phần tử còn lại từ vị trí start đến cuối mảng, 
        thì tất cả các phần tử từ start đến cuối mảng sẽ bị loại bỏ.
    </p>
    <p class="content__desc mb-10 ti-30">
        Nếu deleteCount là 0, phương thức này sẽ không xóa bất kỳ phần tử nào 
        nhưng vẫn có thể thêm các phần tử mới vào mảng tại vị trí chỉ định.
    </p>
    <p class="content__desc ti-30">
        item1, item2, ... (tùy chọn): các phần tử cần được thêm vào mảng, bắt đầu từ vị trí start. 
        Nếu không có phần tử nào được thêm, splice() chỉ đơn giản loại bỏ các phần tử khỏi mảng.
    </p>

    <h3 class="content__heading-4 mt-20 mb-10">Các cách làm việc với splice()</h4>
    <h4 class="content__heading-4 mb-10">1. Thêm phần tử vào mảng</h4>
    <p class="content__desc mb-10">
        Để thêm một hoặc nhiều phần tử vào mảng, 
        bạn chỉ cần đặt deleteCount thành 0 và thêm các phần tử sau đó.
    </p>
    <pre class="language-javascript"><code class="language-javascript">let numbers = [1, 2, 4, 5];

// Thêm số 3 vào vị trí index 2
numbers.splice(2, 0, 3);

console.log(numbers); // [1, 2, 3, 4, 5]</code></pre>
    <blockquote class="blockquote blockquote--normal mt-10">
        <p class="content__desc mb-10">
            Trường hợp thêm một hoặc nhiều phần tử vào 
            đầu hoặc cuối mảng bạn có thể dùng unshift() và push() cho ngắn gọn và đơn giản. 
        </p>
        <p class="content__desc">
            Tuy nhiên, trường hợp cần thêm một hoặc nhiều phần tử 
            vào các vị trí khác bạn sẽ cần sử dụng tới splice().
        </p>
    </blockquote>

    <h4 class="content__heading-4 mt-20 mb-10">2. Loại bỏ phần tử từ mảng</h4>
    <p class="content__desc mb-10">
        Bạn có thể loại bỏ phần tử khỏi mảng bằng cách chỉ định 
        số lượng phần tử cần loại bỏ mà không cần thêm phần tử mới.
    </p>
    <pre class="language-javascript"><code class="language-javascript">let numbers = [1, 2, 3, 4, 5];

// Loại bỏ 3 phần tử bắt đầu từ vị trí 1
numbers.splice(1, 3);

console.log(numbers); // [1, 5]</code></pre>

    <blockquote class="blockquote blockquote--normal mt-10">
        <p class="content__desc">
            Sử dụng shift() và pop() chỉ hiệu quả trong tình 
            huống cần loại bỏ một phần tử ở đầu hoặc cuối mảng. 
            Trong tình huống cần loại bỏ một 
            hoặc nhiều phần tử liên tiếp nhau ở các vị trí khác bạn sẽ cần sử dụng tới splice().
        </p>
    </blockquote>

    <h4 class="content__heading-4 mt-20 mb-10">3. Thay thế phần tử trong mảng</h4>
    <p class="content__desc mb-10">
        Bạn có thể thay thế một hoặc nhiều phần tử 
        trong mảng bằng cách loại bỏ chúng và thêm các phần tử mới cùng một lúc.
    </p>
    <pre class="language-javascript"><code class="language-javascript">let animals = ["Dog", "Cat", "Rabbit", "Horse"];

// Thay thế "Rabbit" bằng "Snake"
animals.splice(2, 1, "Snake");

console.log(animals); // ["Dog", "Cat", "Snake", "Horse"]</code></pre>

    <blockquote class="blockquote blockquote--normal mt-10">
        <p class="content__desc">
            Một cách khác để thay thế "Rabbit" bằng "Snake" ở trên là 
            animals[2] = "Snake". Tuy nhiên cách này chỉ hiệu quả 
            khi thay thế một phần tử. Trường hợp bạn cần thay thế 
            nhiều phần tử một lúc thì cần sử dụng tới splice().
        </p>
    </blockquote>

    <div class="separate"></div>

    <h2 class="content__heading-2 mb-10">Phương thức concat và flat</h2>
    <h3 class="content__heading-3 mb-10">concat</h3>
    <p class="content__desc mb-10">
        Hợp nhất 2 hoặc nhiều mảng thành 1 mảng duy nhất
    </p>
    <p class="content__desc mb-10">
        Cú pháp
    </p>
    <pre class="language-javascript"><code class="language-javascript">let newArray = array1.concat(array2, array3, ..., arrayX);</code></pre>
    
    <p class="content__desc mt-10 mb-10"></p>
        Ví dụ
    </p>
    
    <pre class="language-javascript"><code class="language-javascript">let fruits = ['apple', 'banana'];
let vegetable = ['carrot', 'pea'];

let combined = fruits.concat(vegetable);

console.log(combined); // ['apple', 'banana', 'carrot', 'pea']</code></pre>

    <h3 class="content__heading-3 mt-20 mb-10">flat</h3>
    <p class="content__desc mb-10">
        Làm phẳng mảng. [1, 2, [3, 4]] => [1, 2, 3, 4]
    </p>
    <p class="content__desc mb-10">
        Không truyền đối số thì mặc định là 1
    </p>
    <p class="content__desc mb-10">
        Không làm thay đổi mảng gốc
    </p>

    <pre class="language-javascript"><code class="language-javascript">let arr = [1, 2, [3, 4, [5, 6]]];

let flatArray1 = arr.flat(1);
console.log(flatArray1); // [1, 2, 3, 4, Array(2)]

let flatArray2 = arr.flat(2);
    
console.log(flatArray2); // [1, 2, 3, 4, 5, 6]</code></pre>

    <h4 class="content__heading-4 mt-20 mb-10">Làm phẳng tối đa mảng</h4>
    <p class="content__desc mb-10">
        Sử dụng <b>Infinity</b> để làm phẳng toàn bộ các mảng con.
    </p>

    <pre class="language-javascript"><code class="language-javascript">let deeplyNested = [1, [2, [3, [4, [5]]]]];
let completelyFlat = deeplyNested.flat(Infinity);

console.log(completelyFlat); // [1, 2, 3, 4, 5]</code></pre>
    
    <div class="separate"></div>
    <h2 class="content__heading-2 mb-10">Phương thức forEach</h2>
    <p class="content__desc mb-10">
        Phương thức này không trả về giá trị mới mà chỉ thực hiện 
        hành động lặp qua và xử lý các phần tử của mảng.
    </p>
    <p class="content__desc mb-10">
        Cú pháp
    </p>
    <pre class="language-javascript"><code class="language-javascript">array.forEach(function(currentValue, index, arr) { ... }, thisValue);</code></pre>
    <p class="content__desc mt-10 mb-10"></p>
        Ví dụ
    </p>

    <pre class="language-javascript"><code class="language-javascript">const fruits = ['apple', 'banana', 'cherry'];
fruits.forEach(function(item, index) {
    console.log(index, item); // 0 "apple" // 1 "banana" // 2 "cherry"
});</code></pre>

    <p class="content__desc mt-10 mb-10">
        Dùng forEach thực hiện phép tính tổng
    </p>
    <pre class="language-javascript"><code class="language-javascript">const numbers = [1, 2, 3, 4];
let sum = 0;

numbers.forEach(number => {
    sum += number;
});

console.log(sum); // 10</code></pre>
    <h3 class="content__heading-3 mt-20 mb-10">Khác biệt giữa forEach và vòng lặp khi duyệt mảng</h3>
    <p class="content__desc mb-10">
        Cả forEach và vòng lặp truyền thống (như for, while) 
        đều có thể được sử dụng để duyệt qua các phần tử của mảng trong JavaScript, 
        nhưng chúng có một số khác biệt về cách sử dụng và tính năng.
    </p>
    <h4 class="content__heading-4 mb-10">Khác biệt về tính năng</h4>
    <p class="content__desc mb-10">
        <b>forEach</b>
    </p>
    <p class="content__desc mb-10 ti-30">
        Được thiết kế để duyệt qua mỗi phần tử của mảng một cách dễ dàng 
        và thực thi một hàm cho mỗi phần tử.
    </p>
    <p class="content__desc mb-10 ti-30">
        Không thể sử dụng break hay continue để kết thúc sớm hoặc bỏ qua 
        các phần tử. Việc sử dụng return trong forEach chỉ kết thúc hàm hiện tại 
        chứ không kết thúc vòng lặp, lần lặp tiếp theo vẫn được diễn ra.
    </p>
    <p class="content__desc ti-30 mb-10">
        Chỉ thực hiện hàm với các phần tử có giá trị, không xử lý các phần tử trống (empty).
    </p>
    <p class="content__desc mb-10">
        <b>Vòng lặp truyền thống (for, while):</b>
    </p>

    <p class="content__desc ti-30 mb-10">
        Có thể dừng hoặc thoát khỏi vòng lặp bất cứ lúc nào 
        sử dụng break hoặc return (khi ở trong một hàm).
    </p>
    <p class="content__desc ti-30 mb-10">
        Cho phép điều khiển chi tiết hơn về quá trình lặp, 
        như bỏ qua một số phần tử với continue hoặc 
        điều chỉnh điều kiện lặp tại bất kỳ điểm nào.
    </p>
    <p class="content__desc ti-30 mb-10">
        Luôn duyệt qua tất cả các phần tử của mảng, kể cả các phần tử empty.
    </p>

    <h3 class="content__heading-3 mt-10 mb-10">Khác biệt trong tính ứng dụng</h3>
    <p class="content__desc mb-10">
        <b>Sử dụng forEach:</b>
    </p>

    <p class="content__desc ti-30 mb-10">
        Khi bạn muốn áp dụng một hàm lên mỗi phần tử của mảng và 
        không quan tâm đến việc dừng hoặc thoát vòng lặp.
    </p>
    <p class="content__desc ti-30 mb-10">
        Khi bạn muốn áp dụng một hàm lên mỗi phần tử và muốn viết code gọn gàng, rõ ràng hơn.
    </p>

    <p class="content__desc mb-10">
        <b>Sử dụng vòng lặp truyền thống:</b>
    </p>

    <p class="content__desc ti-30 mb-10">
        Khi bạn cần điều khiển chi tiết hơn quá trình lặp, 
        như dừng lặp khi điều kiện nhất định được thỏa mãn.
    </p>
    <p class="content__desc ti-30 mb-10">
        Khi bạn xử lý các bài toán phức tạp hơn, 
        cần điều chỉnh logic lặp dựa trên điều kiện động.
    </p>

    <p class="content__desc mb-10">
        <b>Khác biệt về sự hiệu quả</b>
    </p>

    <p class="content__desc ti-30 mb-10">
        Vòng lặp truyền thống có thể hiệu quả hơn forEach 
        trong một số trường hợp, đặc biệt là khi bạn cần 
        dừng vòng lặp sớm hoặc bỏ qua một số phần tử cụ thể. 
        forEach có thể mang lại lợi ích về việc viết code sạch sẽ và ít lỗi hơn 
        nhưng có thể không hiệu quả bằng vòng lặp truyền thống khi cần kiểm soát 
        nhiều hơn về luồng thực thi.
    </p>

    <h4 class="content__heading-4 mt-10 mb-10">Thiết kế forEach2</h4>

    <pre class="language-javascript"><code class="language-javascript">Array.prototype.forEach2 = function(callback, thisArg) {
    // Lấy chiều dài của mảng
    const length = this.length;

    // Lặp qua từng phần tử của mảng
    for (let i = 0; i < length; i++) {
        // Kiểm tra phần tử tại vị trí i có
        // tồn tại trong mảng không
        if (i in this) {
            // Gọi hàm callback với ba tham số:
            // phần tử hiện tại, index, và mảng gốc
            // thisArg được sử dụng làm giá trị
            // this trong khi gọi callback
            callback.call(thisArg, this[i], i, this);
        }
    }
};

// trường hợp sử dụng tham số thứ 2 của forEach
const obj = {
    numbers: [1, 2, 3],
    add(number) {
        this.numbers.push(number);
    },
    // sử dụng tham số thứ 2
    import(numbers) {
        numbers.forEach(this.add, this); 
    }

    // hoặc sử dụng Arrow Function không cần tham số thứ 2
    import2(numbers) {
        numbers.forEach(num => this.add(num));
    }
};

obj.add(4);
obj.add(5);
obj.import([6, 7, 8]);

console.log(obj.numbers); // [1, 2, 3, 4, 5, 6, 7]</code></pre>
</div>