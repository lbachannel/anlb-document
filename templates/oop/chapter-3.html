<div class="content-wrap">
    <h2 class="content__heading-2 mb-20">Object & Class</h2>
    <h3 class="content__heading-3 mb-10">Object là gì?</h3>
    <p class="content__desc mb-10">
        Object là: gom n value phức tạp
    </p>
    <p class="content__desc mb-10">
        Là 1 vật thể, thứ gì đó, thing mà có những đặc điểm, hành vi
        là những thứ ta có thể đếm, sờ, mô tả, phân biệt được
    </p>

    <blockquote class="blockquote blockquote--normal mb-10">
        <p class="content__desc">
            Thuộc tính được gọi là <b>instance variable</b>
        </p>
    </blockquote>

    <h3 class="content__heading-3 mb-10">Class là gì?</h3>
    <p class="content__desc mb-10">
        Sự phân nhóm, tên gọi cho 1 nhóm các đối tượng. Theo 1 tiêu chí nào đó
    </p>
    <p class="content__desc mb-10">
        Tiêu chí: hát -> Nhóm <b>CaSi</b>
    </p>
    <p class="content__desc mb-10">
        Tiêu chí: đóng phim -> Nhóm <b>DienVien</b>
    </p>

    <div class="separate"></div>

    <h2 class="content__heading-2 mb-20">Object lưu trữ trong RAM thế nào</h2>
    <p class="content__desc mb-10">SSD - Solid State Drive</p>
    <p class="content__desc mb-10">HDD - Hard Disk Drive</p>
    <p class="content__desc mb-10 ti-30">
        Window nằm trong này
    </p>
    <p class="content__desc mb-10 ti-30" style="padding-left: 29px; text-indent: 0px;">
        Khi máy khởi động Window sẽ đi vào RAM
    </p>
    <p class="content__desc mb-10 ti-30" style="padding-left: 29px; text-indent: 0px;">
        Lúc này CPU mới đọc lệnh trong RAM. Như vậy CPU xử lý chứ không lưu trữ
    </p>
    <p class="content__desc mb-10 ti-30" style="padding-left: 29px; text-indent: 0px;">
        Vấn đề CPU và RAM thì cần phải nhanh (tốc độ của cpu và ram khác nhau). Tuy nhiên RAM nhanh quá mắc tiền
    </p>
    <p class="content__desc mb-10 ti-30" style="padding-left: 29px; text-indent: 0px;">
        Cho nên phải có bước đệm trung gian. Câu lệnh từ RAM đi vào trong CPU tránh bị hẫm quá
    </p>
    <p class="content__desc mb-10 ti-30" style="padding-left: 29px; text-indent: 0px;">
        CPU xử lý nhanh, ram đưa vào chậm. Cho nên RAM phải đưa trước vào CPU 1 số lệnh
    </p>
    <p class="content__desc mb-10 ti-30" style="padding-left: 29px; text-indent: 0px;">
        CPU sẽ chứa 1 số lệnh vừa đủ thôi. Bộ nhớ đó gọi là bộ nhớ cache.
    </p>

    <p class="content__desc mb-10 ti-30" style="padding-left: 29px; text-indent: 0px;">
        Bộ nhớ cache chẳng qua nó giống bộ nhớ ram chẳng qua tốc độ 
        nó cao hơn để đảm bảo độ lệch
        giữa hai thằng là đở.
    </p>
    <p class="content__desc mb-10 ti-30" style="padding-left: 29px; text-indent: 0px;">
        Càng nhiều bộ nhớ cache thì tốc độ xử lý của hệ thống càng cao
    </p>
    <p class="content__desc mb-10 ti-30" style="padding-left: 29px; text-indent: 0px;">
        Tại sao không làm RAM cao => mắc tiền (không đủ làm)
    </p>
    <p class="content__desc mb-10 ti-30" style="padding-left: 29px; text-indent: 0px;">
        Cho nên bộ nhớ cache sẽ rất nhỏ bao nhiêu kb, mb. Còn RAM tính bằng gb
    </p>

    <h3 class="content__heading-3 mb-10">Byte là gì ?</h3>
    <p class="content__desc mb-10">
        8 transistor ở với nhau thì được gọi là 1 byte
    </p>
    <p class="content__desc mb-10">
        1GB = 1 tỷ byte = 8 tỷ bit
    </p>
    <p class="content__desc mb-10">
        Máy tính hoạt động dựa trên transistor (bit)
    </p>
    <p class="content__desc mb-10">
        Transistor bóng đèn điện tử 
        [Transistor được chế tạo từ chất bán dẫn (semiconductor)]. Nó làm trò gì ?
    </p>
    <p class="content__desc mb-10">
        Trong mạch điện tử, thông tin thường được biểu diễn bằng nhị phân, 
        tức là chỉ có hai trạng thái: 0 và 1.
    </p>
    <p class="content__desc mb-10">
        Khi bạn cung cấp tín hiệu 1 (mức điện áp cao) cho chân Base của transistor, nó cho phép dòng điện lớn hơn 
        chạy từ Collector đến Emitter, làm cho bóng đèn sáng lên.
    </p>
    <p class="content__desc mb-10">
        Khi bạn cung cấp tín hiệu 0 (không có điện áp) cho chân Base, transistor 
        ngừng cho dòng điện chạy từ Collector đến Emitter, và bóng đèn tắt.
    </p>
    <p class="content__desc mb-10">
        Từ góc độ nhị phân, việc bật bóng đèn là trạng thái 1 
        (sáng) và tắt bóng đèn là trạng thái 0 (tắt).
    </p>
    <p class="content__desc mb-10">
        Do đó, bạn có thể tưởng tượng việc bật/tắt bóng đèn giống như việc đọc giá trị nhị phân, giúp bạn thực hiện 
        các phép toán logic và điều khiển trong các mạch điện tử.
    </p>

    <blockquote class="blockquote blockquote--normal">
        <p class="content__desc">
            Vì vậy, mối quan hệ giữa transistor, nhị phân và màn hình máy tính 
            là nền tảng cho cách mà thông tin được xử lý và hiển thị. 
            Nó cho phép máy tính diễn giải và thể hiện thông tin mà chúng ta có thể nhìn thấy và tương tác với.
        </p>
    </blockquote>

    <div class="separate"></div>
    <h2 class="content__heading-2 mb-10">Object Inside-Out</h2>
    <pre class="language-javascript"><code class="language-javascript">public static void main(String[] args) {
    Student s1 = new Student("SE123", "Tommy", 1996, 8.9);

    s1 = new Student("SE125", "John", 1997, 8.5);
}</code></pre>
    
    <blockquote class="blockquote blockquote--normal mt-10 mb-10">
        <p class="content__desc mb-10">
            Một vùng ram new Object mà không còn ai trỏ tới. JVM có chương trình ngầm gọi là GARBAGE COLLECTOR (Cty môi trường đô thị)
        </p>
        <p class="content__desc mb-10">
            JVM máy ảo Java chạy trên Windows, giám sát vùng ram app viết bằng Java. Có cà chớn không, giết app, cảnh báo khi chơi try-catch
        </p>
        <p class="content__desc mb-10">
            Ngoài ra nó giám sát có vùng new mồ côi nào không, vùng Heap không con trỏ
        </p>
        <p class="content__desc mb-10">
            Vùng HEAP sẽ bị clear. Garbage Collector sẽ tự động giải phóng bộ nhớ mà đối tượng này chiếm giữ. Điều này giúp tránh lãng phí tài nguyên và tránh hiện tượng memory leak (rò rỉ bộ nhớ).
        </p>
        <p class="content__desc mb-10">
            Garbage Collection không xảy ra ngay lập tức khi một đối tượng mất tham chiếu, mà sẽ được kích hoạt tự động khi Java cần giải phóng bộ nhớ, đặc biệt khi:
        </p>
        <p class="content__desc mb-10 ti-30">
            Bộ nhớ heap gần đầy.
        </p>
        <p class="content__desc mb-10 ti-30" style="padding-left: 29px; text-indent: 0px;">
            Ứng dụng yêu cầu nhiều bộ nhớ và cần giải phóng các đối tượng không còn được sử dụng.
        </p>
        <p class="content__desc">
            Bạn có thể gợi ý cho JVM kích hoạt Garbage Collection 
            sớm hơn bằng cách gọi System.gc(), nhưng việc này chỉ là gợi ý, 
            không đảm bảo rằng Garbage Collection sẽ diễn ra ngay lập tức.
        </p>
    </blockquote>

    <p class="content__desc mb-10">
        <b>Backup Object</b>
    </p>
    <pre class="language-javascript"><code class="language-javascript">public static void main(String[] args) {
    Student s1 = new Student("SE123", "Tommy", 1996, 8.9);

    Student backupObj = s1;

    s1 = new Student("SE125", "John", 1997, 8.5);
}</code></pre>

    <p class="content__desc mb-10">
        <b>2 biến Object cùng trỏ cùng 1 vùng new</b>
    </p>
    <pre class="language-javascript"><code class="language-javascript">public static void main(String[] args) {
    Student s1 = new Student("SE123", "Tommy", 1996, 8.9);

    Student s2 = s1; // cùng tọa độ, cùng địa chỉ, cùng 1 vùng nhớ HEAP
}</code></pre>

    <p class="content__desc mb-10">
        <b>Anonymous Object: object vô danh</b>
    </p>
    <pre class="language-javascript"><code class="language-javascript">public static void main(String[] args) {
    new Student("SE666789", "AHIHI", 1999, 8.9).showProfile();
}</code></pre>

    <p class="content__desc mb-10">
        <b>Hàm trả về tọa độ của 1 object</b>
    </p>
    <pre class="language-javascript"><code class="language-javascript">public static Student getStudent() {
    Student s1 = new Student("SE666789", "AHIHI", 1999, 8.9);
    return s1;
}</code></pre>


    <div class="separate"></div>
    <h2 class="content__heading-2 mb-10">toString()</h2>
    <p class="content__desc mb-10">
        Mặc định, phương thức này trả về một chuỗi bao gồm 
        tên lớp của đối tượng và mã băm (hexa) của nó.
    </p>
    <p class="content__desc mb-10">
        Không cần override. Khi System.out.println(chiHu); // gọi thầm toString()
    </p>
    <p class="content__desc mb-10">
        JVM sẽ tự động băm cái vùng RAM của Object thành con số HEXA.
    </p>
    <P class="content__desc mb-10">
        Đại diện cho value vùng RAM đó
    </P>
    <p class="content__desc mb-10">
        Hash number <=> mã băm <=> mã Hexa => nén toàn bộ Data thành 1 con số
        MD5, SHA-256...
    </p>
    <p class="content__desc mb-10">
        Ví dụ:
    </p>
    <pre class="language-javascript"><code class="language-javascript">data.Person@15db9742 // 15db9742 : hệ 16 
data.Person@6d06d69c // 6d06d69c : hệ 16</code></pre>
    <p class="content__desc mt-10 mb-10">
        Tuy nhiên, việc ghi đè phương thức này giúp bạn có thể tùy chỉnh 
        cách thức đại diện cho đối tượng dưới dạng chuỗi.
    </p>
    <p class="content__desc mb-10">
        Ví dụ:
    </p>
    <pre class="language-javascript"><code class="language-javascript">@Override
public String toString() {
    return "Person{name='" + name + "', age=" + age + "}";
}</code></pre>

    <div class="separate"></div>
    <h2 class="content__heading-2 mb-10">Encapsulation</h2>
    <pre class="language-javascript"><code class="language-javascript">public class Dog {
    public String name;
    private int yob;
    private double weight;

    public Dog(String name, int yob, double weight) {
        this.name = name;
        this.yob = yob;
        this.weight = weight;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getYob() {
        return yob;
    }

    public void setYob(int yob) {
        this.yob = yob;
    }

    public double getWeight() {
        return weight;
    }

    public void getWeight(double weight) {
        this.weight = weight;
    }

    public void bark() {
        System.out.printf("|%-10s|%4d|%4.1f|\n", name, yob, weight);
    }
}</code></pre>

    <p class="content__desc mt-10 mb-10 color-red">CÂU HỎI PHỎNG VẤN</p>

    <blockquote class="blockquote blockquote--normal mt-10">
        <p class="content__desc mb-10">
            <b>Encapsulation</b> là quá trình đóng gói các 
            <b>thuộc tính</b> và <b>phương thức</b> trong một class
        </p>
        <p class="content__desc mb-10">
            đồng thời bảo vệ chúng bằng cách kiểm soát truy cập thông qua 
            các mức độ truy cập (<b>access modifiers</b>) như <b>private</b>, 
            <b>protected</b>, và <b>public</b>.
        </p>
        <p class="content__desc">
            Điều này giúp bảo vệ dữ liệu và ẩn chi tiết thực thi khỏi người dùng bên ngoài.
        </p>
    </blockquote>
</div>